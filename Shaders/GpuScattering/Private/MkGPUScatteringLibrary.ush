// Copyright Epic Games, Inc. All Rights Reserved.
#include "/Engine/Private/Common.ush"


// https://gamedev.stackexchange.com/questions/32681/random-number-hlsl
#define RANDOM_IA 16807
#define RANDOM_IM 2147483647
#define RANDOM_AM (1.0f/float(RANDOM_IM))
#define RANDOM_IQ 127773u
#define RANDOM_IR 2836
#define RANDOM_MASK 123459876

struct FNumberGenerator
{
	int seed; // Used to generate values.

    // Returns the current random float.
	float GetCurrentFloat()
	{
		Cycle();
		return RANDOM_AM * seed;
	}

    // Returns the current random int.
	int GetCurrentInt()
	{
		Cycle();
		return seed;
	}

    // Generates the next number in the sequence.
	void Cycle()
	{
		seed ^= RANDOM_MASK;
		int k = seed / RANDOM_IQ;
		seed = RANDOM_IA * (seed - k * RANDOM_IQ) - RANDOM_IR * k;

		if (seed < 0)
			seed += RANDOM_IM;

		seed ^= RANDOM_MASK;
	}

    // Cycles the generator based on the input count. Useful for generating a thread unique seed.
    // PERFORMANCE - O(N)
	void Cycle(const uint _count)
	{
		for (uint i = 0; i < _count; ++i)
			Cycle();
	}

    // Returns a random float within the input range.
	float GetRandomFloat(const float low, const float high)
	{
		float v = GetCurrentFloat();
		return low * (1.0f - v) + high * v;
	}

    // Sets the seed
	void SetSeed(const uint value)
	{
		seed = int(value);
		Cycle();
	}
};

//
float Halton(uint Index, uint Base)
{
	float Result = 0.0f;
	float InvBase = 1.0f / (float) (Base);
	float Fraction = InvBase;
	while (Index > 0)
	{
		Result += (Index % Base) * Fraction;
		Index /= Base;
		Fraction *= InvBase;
	}
	return Result;
}

bool IsWithinSlopeAngle(float NormalZ, float MinAngle, float MaxAngle /*, float Tolerance = (1.e-8f)*/)
{
	float Tolerance = (1.e-8f);
	const float MaxNormalAngle = cos(radians(MaxAngle));
	const float MinNormalAngle = cos(radians(MinAngle));
	if (MaxNormalAngle > (NormalZ + Tolerance) || MinNormalAngle < (NormalZ - Tolerance))
	{
		return false;
	}

	return true;
}


//~ random funcs
float2 random2(float2 p)
{
	return frac(sin(float2(dot(p, float2(127.1f, 311.7f)), dot(p, float2(269.5f, 183.3f)))) * 43758.5453f);
}
//~ end of random funcs

float3 voronoiNoise(float2 uv, float scale, float2 resolution, float animateOffset)
{
	float3 color = float3(0, 0, 0);
	float2 st = uv * (resolution.x / resolution.y) * scale;
	float2 i_st = floor(st);
	float2 f_st = frac(st);

	float m_dist = 1;

	for (int y = -1; y <= 1; y++)
	{
		for (int x = -1; x <= 1; x++)
		{
			float2 neighbor = float2(float(x), float(y));

			//	random position from current + neighbor
			float2 p = random2(i_st + neighbor);
			//	animate point
			p = .5f + .5f * sin(animateOffset + 6.2381f * p);

			//	vector between pixel and the pixel
			float2 diff = neighbor + p - f_st;
			float dist = length(diff);
			m_dist = min(m_dist, dist);
		}
	}
	//	draw the min distance
	color += m_dist;
	//	draw cell center
	return color;
}
